#!/usr/bin/ruby -w

require 'optparse'
require 'lib/wakeonlan'

class Runner  
  def self.parse(args)
    args = ["-h"] if args.empty?
    
    options = {}
    options[:brief] = false
    options[:address]  = "255.255.255.255"
    options[:port] = 9
    options[:interval] = 0.01
    options[:count] = 3
    options[:macs] = []

    opts = OptionParser.new do |opts|
      # Set a banner, displayed at the top
      # of the help screen.
      opts.banner = "Usage: wol -a ADDRESS ff:ff:ff:ff:ff:ff"

      opts.separator ""
      opts.separator "Specific options:"

      opts.on( '-q', '--quiet', 'No console output' ) do
        options[:brief] = true
      end

      opts.on( '-a', '--address 255.255.255.255', 'Address to send to' ) do |address|
        options[:address] = address
      end

      opts.on( '-p', '--port 9', 'Send to port n. Default 9' ) do |port|
        options[:port] = port
      end

      opts.on( '-i', '--interval 0.01', 'Interval between sending packets in seconds') do |interval|
        options[:interval] = interval
      end

      opts.on( '-c', '--count 3', 'Number of packets to send. Default 3') do |count|
        options[:count] = count
      end

      opts.separator ""
      opts.separator "Common options:"

      opts.on_tail( '-h', '--help', 'Display this message' ) do
        puts opts
        exit
      end
    end

    begin
      opts.parse!(args)

      args.each do |arg|
        options[:macs] << arg if /^(\S{1,2}:\S{1,2}:\S{1,2}:\S{1,2}:\S{1,2}:\S{1,2})?$/.match(arg)
      end

      options[:macs].uniq!
      
      options
    rescue OptionParser::InvalidOption => e
        STDERR.puts e.message, "\n", opts
        exit(-1)
    end
  end
end

options = Runner.parse(ARGV)

puts WakeOnLan.new(options).wake